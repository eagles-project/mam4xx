{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>MAM4xx is a performance-portable, GPU-capable C++ implementation of the 4-mode version of the Modal Aerosol Model (MAM), intended for use with E3SM.</p> <ul> <li>The Installation guide shows you how to build and install   MAM4xx on your own machine or on a supported high-performance platform.</li> <li>The Developer guide lays out some basic principles and   guidelines we use in developing MAM4xx.</li> <li>In the Testing guide, we describe in general terms the   methodology we use to test MAM4xx and its aerosol processes.</li> </ul>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>MAM4xx was developed by an interdisciplinary team consisting of aerosol and atmospheric researchers, applied mathematicians, and software engineers. It was created for the EAGLES project, an effort to improve the treatment of aerosols in E3SM, the Department of Energy's global climate model. The source code is available on GitHub. This effort was funded by the Office of Science's Biological and Environmental Research Program.</p>"},{"location":"clang-format/","title":"Getting <code>clang-format</code> version 14","text":"<p>If you don't have the <code>mam4xx</code>-required version 14 of <code>clang-format</code> on your system and you're a Mac user, the likely easiest way to obtain it (because <code>clang-format@14</code> is not available on its own) is by using <code>homebrew</code> to install <code>llvm@14</code>  and then adding it to your path. e.g., <pre><code>$ brew install llvm@14\n$ export PATH=\"/opt/homebrew/opt/llvm@14/bin/clang-format:$PATH\"\n# Note: this is where it is for me on M1 mac--may be different on another system\n# you can confirm where yours is with 'brew info llvm@14'\n$ which clang-format\n/opt/homebrew/opt/llvm@14/bin/clang-format\n</code></pre> For non-mac users, I'd first check to see if <code>llvm v14</code> (or <code>clang-format v14</code>) is provided by your package manager. If not, you can always manually install and build <code>llvm v14</code>, though it's a slightly heavier lift than the above. First steps are: <pre><code>git clone git@github.com:llvm/llvm-project.git\ngit checkout llvmorg-14.0.6 # version tag\n</code></pre> Here is the github repo for <code>llvm v14</code>, and it'll build faster/smaller if you use the flag <code>-DLLVM_ENABLE_PROJECTS=\"clang\"</code> to only build <code>clang</code> and it's friends, rather than all of <code>llvm</code>. Other than that, the README offers solid guidance.</p>"},{"location":"clang-format/#unnecessary-but-convenient-workflow-customization","title":"Unnecessary but Convenient Workflow Customization","text":"<p>If you'd like to add a layer of automation/complexity to ensure you only use <code>clang-format v14</code> on <code>mam4xx</code> and/or want to use a newer version on the rest of your system, I'm a big fan of a terminal tool called direnv (<code>brew install direnv</code>) that allows you to automatically load and unload environment variables based on <code>$PWD</code> using a <code>.envrc</code> file. As an example, here's my <code>.envrc</code> that adds <code>clang-format v14</code> to the path when I'm working on <code>mam4xx</code>. <pre><code>PATH_add /opt/homebrew/opt/llvm@14/bin/clang-format\n\n# also, since I often forget to load a python environment that's required for\n# running ctest, this creates or loads a python 3 virtual environment with numpy\nlayout python3\npip install --upgrade pip\n# the upgrade isn't strictly necessary but trades a little extra setup on the front end to avoid pip endlessly reminding you to update\npip install numpy\n</code></pre> This file is placed in the top-level <code>mam4xx</code> directory and runs when I <code>cd mam4xx</code>, stays loaded in any subdirectories, and clears everything it does when exiting to a directory above or outside of <code>mam4xx</code>. Then run <code>direnv allow</code> to enable the functionality. For the <code>conda</code> people, I've also used this tool to auto-load a pre-configured <code>conda</code> environment since the <code>.envrc</code> is basically a bash script with a few bells and whistles added. In case anyone's curious, here's a fancier version that I use to setup an environment for a jupyter notebook (no promises on robustness of this script \ud83d\ude42).</p>"},{"location":"development/","title":"Developing MAM4xx","text":"<p>Welcome to the MAM4xx development team! MAM4xx is a function-by-function port of MAM4 (the 4-mode Modal Aerosol Model package) from Fortran to \"performance portable\" C++ code that can run on GPU accelerators as well as traditional CPUs.</p> <p>This C++ port of MAM4 provides a much-needed prognostic aerosol capability to the Energy Exascale Earth System Model (E3SM), which is designed to run on the Department of Energy's leadership-class computing facilities.</p>"},{"location":"development/#getting-help","title":"Getting Help","text":"<p>You're part of a team. That means you shouldn't have to sit alone with a problem and scratch your head until the solution magically appears inside it. If you're stuck, organize your thoughts and ask another member of the team for their input. Not only can this save you time, but it can also help you build productive relationships with other team members.</p> <p>If you're a member of the MAM4xx development team on the EAGLES Project, the easiest way to seek help is to post a Slack message to the appropriate channel. We have access to an <code>ESMD-BER</code> Slack workspace with some useful channels for asynchronous team communication:</p> <ul> <li><code>eagles-mam-cpp</code>: This is the best channel for discussing and troubleshooting   issues related to MAM4xx development.</li> <li><code>eagles_haero</code>: This channel is for discussing the HAERO aerosol package   \"toolbox\" used by MAM4xx.</li> <li><code>eagles_mamrefactor</code>: In this channel, you can ask questions about the   MAM4 box model used for   porting MAM4's aerosol microphysics parameterizations.</li> </ul> <p>If you're not already on the <code>ESMD-BER</code> Slack workspace, please ask a team member to send you an invitation.</p> <p>If you like, you can also create issues in the MAM4xx repository itself.</p>"},{"location":"development/#the-big-picture","title":"The Big Picture","text":"<p>MAM4xx makes the 4-mode modal aerosol model (\"MAM4\") available to EAMxx (aka \"SCREAM\"), which is written in C++ and uses Kokkos to achieve good parallel performance on platforms of interest to the DOE's Office of Science. EAMxx has a lot of moving parts, but MAM4xx mainly interacts only with a data structure called the Atmosphere Driver (AD).</p>"},{"location":"development/#terminology","title":"Terminology","text":"<ul> <li>A host model is an atmospheric model containing a dynamical core that   solves a transport equation for mass in the atmosphere, and several physics   packages that parameterize important atmospheric processes that can't be   resolved by the underlying grid. EAMxx is the atmospheric host model used   by E3SM version 4, so when we refer to the \"host model\", we refer to EAMxx.</li> <li>An aerosol package is a physics package that provides a representation of   aerosols (prognostic and diagnostic variables, and tendencies for evolving   the prognostics) for use by a host model. The aerosol package of interest for   us, of course, is MAM4xx.</li> <li>An aerosol process is a set of functions associated with a specific part   of the aerosol lifecycle (e.g. nucleation, coagulation, aging) that calculate   updates to aerosol-related quantities.</li> <li>An aerosol parameterization is a function that computes one or more   quantities needed to update aerosol-related quantities. An aerosol process can   contain one or more related parameterizations.</li> <li>A prognostic variable is a quantity in the atmosphere whose evolution is   described by a differential equation. Prognostic variables cannot be obtained   using closed-form (algebraic) equations.</li> <li>A diagnostic variable is a quantity in the atmosphere that can be   expressed in terms of prognostic variables in closed form (usually some   algebraic expression).</li> <li>A tendency is a time derivative (\"rate of change\") associated with a   prognostic variable. An aerosol process computes tendencies given a set of   prognostic variables.</li> <li>An atmospheric state is a complete quantitative description of the   atmosphere according to a host model. This description consists entirely of   prognostic and diagnostic variables.</li> </ul>"},{"location":"development/#eamxxs-atmosphere-driver","title":"EAMxx's atmosphere driver","text":"<p>In essence, an atmospheric host model does the following things: 1. it initializes the state of the atmosphere at the beginning of the simulation 2. it advances the state of the atmosphere and the simulation time in a sequence    of discrete \"time steps\". Within each time step of length <code>dt</code>, tendencies    are computed for each of the prognostic variables, and the atmospheric state    is updated from time <code>t</code> to time <code>t + dt</code> by integrating these tendencies</p>"},{"location":"development/#eamxxs-atmosphere-processes","title":"EAMxx's atmosphere processes","text":"<p>To evolve the state of the atmosphere over a time period <code>[t, t+dt]</code>, EAMxx has an <code>AtmosphereDriver</code> object that orchestrates changes to the atmospheric state resulting from different atmospheric processes. Each of these processes is represented by a class derived from the <code>AtmosphereProcess</code> base class. The slide below, taken from the MAM4xx kick-off meeting, illustrates the different atmospheric processes within EAMxx.</p> <p></p> <p>The objective of our project is to implement one or more <code>AtmosphereProcess</code> subclasses that represent the effects of aerosols on the atmosphere.</p>"},{"location":"development/#aerosol-atmosphere-processes","title":"Aerosol atmosphere processes","text":"<p>Within an aerosol-related <code>AtmosphereProcess</code> subclass, we extract data from EAMxx, feed it into MAM4xx's data structures, run a set of aerosol processes, and then incorporate the resulting output back into EAMxx's atmospheric state. The process is roughly illustrated in this slide (also taken from the MAM4xx kick-off meeting):</p> <p></p>"},{"location":"development/#mam4xx-code-structure","title":"MAM4xx Code Structure","text":""},{"location":"development/#aerosol-processes-and-parameterizations","title":"Aerosol processes and parameterizations","text":"<p>Aerosols are long polymer chains that are emitted from the surface of the earth and/or that form in the atmosphere as a result of collisions between gas particles. Aerosol particles have an outsized influence on cooling and warming processes in the atmosphere, and interact strongly with incoming solar radiation.</p> <p></p> <p>It is not possible to describe aerosol dynamics in terms of purely mechanistic processes. Instead, aerosols are assumed to form and evolve over a set of distinct stages in an \"aerosol life cycle.\" These stages are conceptually convenient and represent phenomenology that can be compared with experimental observations. Because of this phenomenological approach, each stage of the aerosol lifecycle (which we call an \"aerosol process\") must be parameterized: in other words, an aerosol process is quantified in terms of a set of parameters that determine how the aerosols evolve over time.</p> <p>Different aerosol models can decompose the aerosol lifecycle into different stages (processes). MAM4xx uses the aerosol processes defined by MAM4.</p>"},{"location":"development/#aerosol-process-data-structures","title":"Aerosol process data structures","text":"<p>MAM4xx uses several data structures defined in HAERO. In particular:</p> <ul> <li>The <code>Real</code>   type is a floating point number in single or double precision, depending on   how HAERO was configured.</li> <li>The <code>ColumnView</code>   type is a Kokkos view (array) representing a quantity defined on an   atmospheric column. See the section on Kokkos views below for more details on   this type.</li> <li>The <code>AeroProcess</code>   class template defines the interface for an aerosol process.</li> <li>The <code>Atmosphere</code>   class defines the state of the atmosphere, which is typically used as input   data for aerosol processes.</li> <li>The <code>AeroSpecies</code>   and <code>GasSpecies</code>   types define the respective physical properties of aerosol and gas   molecules present in the atmosphere.</li> <li>The <code>ThreadTeam</code>   type is used to control a team of threads allocated to a single atmospheric   column. It's used in Kokkos <code>parallel_for</code> loops.</li> </ul> <p>The most interesting of these data types is the <code>AeroProcess</code> class template. <code>AeroProcess</code> has two template parameters that define its behavior:</p> <ol> <li><code>AerosolConfig</code>, which defines parameters that describe the aerosols of concern    and their particle size distribution properties. It also defines data types    used by aerosol processes, like <code>Prognostics</code> (prognostic variables),    <code>Diagnostics</code> (diagnostic variables), and <code>Tendencies</code> (rates of change for    prognostic variables). In MAM4xx, we use the    <code>mam4::AeroConfig</code>    type for the <code>AerosolConfig</code> template parameter for all <code>AeroProcess</code> types.</li> <li><code>AerosolProcessImpl</code>, which implements the behavior for an <code>AeroProcess</code> type    in several methods, including<ul> <li>an <code>init</code> method, which is called upon construction and accepts an    <code>AerosolConfig</code> object and a process-specific <code>AerosolProcessImpl::Config</code>    object that can be used by the process implementation</li> <li>a <code>validate</code> method, which validates data in the given <code>Atmosphere</code> and    <code>Prognostics</code> objects. Often, this means checking for negative quantities,    which are unphysical.</li> <li>a <code>compute_tendencies</code> method, which \"runs the process\" at a given time    over a given duration and computes tendencies for each of the prognostic    variables present</li> </ul> </li> </ol> <p>When we say we're porting MAM4 to C++ from Fortran, we're talking about writing an <code>AerosolProcessImpl</code> class for each of the aerosol processes in MAM4 and filling the <code>compute_tendencies</code> method with the relevant ported Fortran code. To see specific examples of aerosol process implementations, take a look at the <code>mam4::Nucleation</code> and <code>mam4::GasAerExch</code> classes, which implement nucleation and gas-aerosol exchange (a.k.a. \"condensation\").</p> <p>HAERO contains several other data structures in addition those mentioned above. More details on these data structures can be found in the HAERO documentation.</p>"},{"location":"development/#c-guidelines","title":"C++ Guidelines","text":"<p>C++ is a large, multi-paradigm programming language. The way C++ is used has changed so many times over the years that it's crucial for us to decide how much of the language we use, and how we'll use it.</p> <p>Much of this section is up for debate/discussion, but here are some guiding principles that are unlikely to change:</p> <ol> <li>Favor clarity over cleverness. Anyone can write code that no one else    can understand. Writing simple code that is intelligible to people of various    skill levels is challenging, but worth the investment in time and effort.    \"Don't be clever.\" -Bjarne Stroustrup</li> <li>Avoid frivolous use of C++ features. The language is huge, and our job is    not to maximize our use of it, but to use it effectively.    \"Every new powerful feature will be overused and misused.\"    -Bjarne Stroustrup</li> <li>Remember your audience. We're writing science codes, so what we write    must be intelligible to scientists and others without formal training in    software engineering. Don't use <code>int x{};</code> when <code>int x = 0;</code> does the same    thing with more clarity.    \"Only half of the C++ community is above average.\" -Bjarne Stroustrup</li> </ol> <p>The astute reader may notice a certain redundancy or even repetition in these principles. It is left as an exercise to ponder why that might be so.</p>"},{"location":"development/#style","title":"Style","text":"<p>We adhere somewhat loosely to LLVM's C++ Style Guide, with a few notable exceptions:</p> <ul> <li>We allow the use of C++ exceptions, since simulation codes have rather   simplistic error handling requirements.</li> <li>Names of functions, methods, and variables use <code>snake_case</code>, not   <code>camelCase</code> or <code>PascalCase</code>.</li> <li>We typically use braces to enclose logic for all <code>if</code>/<code>else</code>/loop statements   even if they are only a single line, for consistency and readability.</li> <li>We use <code>EKAT_ASSERT</code> instead of <code>assert</code> to ensure that all MPI processes   are properly shut down when a program terminates because of a violated   assertion (when MPI is enabled).</li> </ul> <p>These style conventions are enforced with the following build targets, which you can run from your build directory:</p> <ul> <li><code>make format-cxx-check</code>: checks C++ formatting in all source files and reports   any non-conforming code</li> <li><code>make format-cxx</code>: applies C++ formatting rules to all source files, editing   them in place. Try to do this in a separate commit from your other work.</li> </ul> <p>These targets are only available if you have <code>clang-format</code> on your system, and they only perform their work if you have the version we support. If you have an unsupported version of <code>clang-format</code>, the targets will tell you the right version to install. Here is a guide to getting the supported version of <code>clang-format</code> that is a bit more geared toward Mac users than others.</p>"},{"location":"development/#best-practices","title":"Best practices","text":"<p>The bullets in the LLVM C++ Style Guide provide good guidelines for best practices. Here are some additional tips/opinions:</p> <ul> <li>Avoid inheritance where possible: C++'s model of inheritance is easy to   use but often hard to understand. When possible organize things so that   objects belong to other objects instead of inheriting from them. Sometimes   this approach is articulated as composition over inheritance.   In particular, when you are tempted to use inheritance to bestow the   capabilities of one type upon another, pause for a moment to think about   whether there's a better way to accomplish what you're trying to do.</li> <li>Make effective use of the standard library, but don't overdo it: Sometimes   the clearest expression of an algorithm uses a <code>for</code> loop and not a devilishly   clever concoction of esoteric STL types, traits, and functional wizardry.   This is particularly true when writing code that runs on a GPU, for which the   standard template library is largely unavailable!</li> </ul>"},{"location":"development/#kokkos-ekat-haero-intra-node-parallelism","title":"Kokkos, EKAT, Haero: Intra-node Parallelism","text":"<p>MAM4xx is written in \"performance-portable\" C++ code using Kokkos to dispatch parallelizable workloads to threads on CPUs or GPUs on a compute node. Kokkos allows developers to write code that is very nearly standard C++ that can run on GPU accelerators, which makes it unnecessary to learn specialized accelerator languages like CUDA and HIP.</p> <p>Because MAM4xx is based on column physics, it operates on sets of independent vertical atmospheric columns and can do all of its work within a single compute node. In other words, a MAM4xx instance on a compute node has no specific need to communicate with other nodes. However, the host model that uses MAM4xx almost certainly needs inter-nodal communication, for which MPI is used.</p> <p>The high-performance data types in MAM4xx used for these parallel dispatches are all provided by Kokkos. Kokkos is a general-purpose parallel programming model, and is accordingly complex, with many elaborate features and options. In order to reduce this complexity and focus on decisions and logic related to earth system models (ESMs) in general and aerosols in particular, we make use of a couple of additional layers:</p> <ul> <li>E3SM/Kokkos Application Toolkit (EKAT):   A library that defines specific Kokkos-based data structures relevant to   E3SM-related projects, and some useful bundled external libraries:<ul> <li><code>yamlcpp</code>: a C++ YAML parser for handling configuration files</li> <li><code>spdlog</code>: a fancy C++ logging system that provides multiple loggers and             extensible logging levels</li> <li><code>fmt</code>: a fancy C++ formatting system that provides Python-like formatting          for C++ strings</li> </ul> </li> <li>High performance AEROsol interface (HAERO):   A library that defines data types for aerosol packages. HAERO relies heavily   upon EKAT, but makes a lot of choices appropriate for aerosol column physics   so we can focus on solving relevant problems and not reinventing the wheel   over and over.</li> </ul> <p>If MPI is enabled, EKAT configures MPI in its own build system, and this configuration is passed along to HAERO and MAM4xx. If you enable MPI, you'll need an implementation on your system like OpenMPI or MPICH.</p> <p>In this section, we describe the data structures provided by HAERO (via EKAT and Kokkos). The Kokkos documentation and tutorials are fantastic resources for understanding the most important data structures and techniques we use.</p>"},{"location":"development/#views-c-multidimensional-arrays","title":"Views: C++ multidimensional arrays","text":"<p>Fortran programmers have long been skeptical about using C++ as a scientific programming language because C++ doesn't have multidimensional arrays. (This has also frustrated a lot of C++ programmers in the HPC community!)</p> <p>Kokkos provides a solution to this problem: the View data structure. A <code>View</code> is basically a multidimensional array that lives in a specific memory location (either on a CPU or a GPU). The <code>View</code> type has several template parameters that dictate what it stores, where it stores things, and how it indexes them.</p> <p>As a multidimensional array, a <code>View</code> has a rank that indicates the number of indices it possesses. For example, a rank-1 <code>View</code> <code>V</code> has a single index, allowing you to retrieve the <code>i</code>th value with the syntax <code>V(i)</code>. A rank-3 <code>View</code> <code>T</code> has three indexes, providing access to an element with the syntax <code>T(i, j, k)</code>.</p> <p>Some people refer to the rank of a View as its dimension, but this term actually refers to the number of elements for a specific index. For example, the dimension of the second index of <code>T</code> above is the valid number of values of <code>j</code> that can be used in the expression <code>T(i, j, k)</code>. Indices in a <code>View</code> run from <code>0</code> to <code>dim-1</code>, where <code>dim</code> is the dimension relative to the index in question. The shape of a <code>View</code> is the set of dimensions of its indices. For example, the rank-3 <code>View</code> <code>T</code> may have a shape of <code>(100, 100, 100)</code>.</p> <p>The <code>View</code> type is very flexible, so it can be complicated to work with directly. HAERO provides a few useful types that nail down the various parameters according to the needs of aerosol column physics:</p> <ul> <li><code>ColumnView</code>: a rank-1 <code>View</code> whose index (typically written <code>k</code>) identifies   a specific vertical level in a column of \"air\" in the atmosphere. This type   of <code>View</code> is used to represent all quantities of interest in an aerosol   parameterization.</li> <li><code>TracersView</code>: a rank-3 <code>View</code> with indices <code>n</code>, <code>i</code>, <code>k</code>, that identify a   specific tracer (advected quantity) <code>n</code> in a specific column <code>i</code> at a specific   vertical level <code>k</code>. This <code>View</code> type is used to extract prognostic aerosol   data from an atmospheric host model (e.g. EAMxx) so it can be advanced by   MAM4xx.</li> <li><code>DiagnosticsView</code>: a rank-3 <code>View</code> similar to <code>TracersView</code>, used to index   diagnostic aerosol data from an atmosphereic host model for use and updating   by MAM4xx.</li> </ul> <p>These three <code>View</code> types should be all you need to implement aerosol processes and their parameterizations. In fact, the aerosol processes themselves really only use the <code>ColumnView</code> type.</p> <p>NOTE: You may be tempted to use <code>View::extent</code> to determine the size of a <code>View</code>. While this is perfectly reasonable under normal circumstances, there are cases where a <code>View</code> might be larger than you would expect. This has to do with EAMxx's vectorization strategy, which allocates and aligns memory for <code>View</code>s assuming a minimum \"block size\" for data. For MAM4xx, all of our <code>ColumnView</code> variables will be functionally equal in length to the number of vertical levels in the atmosphere, but the actual extents may be greater.</p>"},{"location":"development/#parallel-dispatch-host-and-device","title":"Parallel dispatch: host and device","text":"<p>MAM4xx runs within a single process runs on an entire compute node, no matter how many CPUs or GPUs are available to that node. Within MAM4xx, processes on different compute nodes typically don't communicate directly with each other. Instead, the host model coordinates communication between these processes using MPI, and MAM4xx relies on the host model to get consistent data.</p> <p>To understand the intranodal parallelism used by MAM4xx, we need some terminology:</p> <ul> <li>The compute host is the CPU running the process containing the atmospheric   host model and MAM4xx. The compute host manages the control flow of the host   model and MAM4xx--it can also do numerical calculations, but such   calculations can't be done in parallel on the host.</li> <li>The compute device is where numerical calculations are performed in   parallel. On a node with only CPUs, the role of the compute device is played   by the same CPU as that for the compute host. On a node with access to GPUs,   the compute device is the GPU, which has its own memory and (very different!)   processing hardware. Logically, the compute device is distinct from the   compute host, because only the compute device can execute code in parallel.</li> </ul> <p>Strictly speaking, a machine can have more than one compute device. For example, a many-core CPU with a GPU has two potential compute devices: the CPU and the GPU. We will ignore this possibility and assume that all calculations are done on a single compute device, which we call the device.</p> <p>To make use of the device on a compute node, MAM4xx uses the parallel dispatch capabilities provided by Kokkos. MAM4xx's \"column physics\" approach allows it to take advantage of a specific parallel dispatch approach based on the Kokkos TeamPolicy. This EAMxx Confluence page explains how it works.</p>"},{"location":"development/#frequently-asked-questions","title":"Frequently Asked Questions","text":"<p>How are the atmospheric columns laid out in EAMxx?</p> <p>This Confluence page describes the computational grid(s) used by EAMxx.</p>"},{"location":"development/#resources","title":"Resources","text":"<ul> <li>EKAT repository</li> <li>E3SM website</li> <li>Kokkos documentation</li> <li>HAERO repository</li> <li>LLVM C++ Style Guide</li> <li>MAM4 box model repository</li> <li>SCREAM (EAMxx) repository</li> <li>Skywalker documentation</li> </ul>"},{"location":"dot_envrc/","title":"Example <code>.envrc</code> for Jupyter Notebook Virtual Environment","text":"<pre><code>echo '=================================='\necho 'loading .envrc virtual environment'\necho '=================================='\n\n# this (more or less) creates a python 3 virtual environment\nlayout python3\n\n# this and the similar bit below is my hacky way of trying to not re-update pip\n# or reinstall packages\nexport pip_flagDir=${PWD}/.direnv/python-3.11.4/pip_flags\nmkdir -p $pip_flagDir\necho \"UPDATE PIP?\"\n# if the flag file is there, don't update\nif [ ! -f \"${pip_flagDir}/.pip_updated\" ]; then\necho 'updating pip now'\npip install --upgrade pip\n  pip_success=$?\nif (( pip_success &lt; 1 )); then\ntouch $pip_flagDir/.pip_updated\n  fi\nelse\necho 'pip previously updated'\nfi\n\n# declare an array of pip packages\npip_installs=(\n\"ipython\"\n\"ipykernel\"\n\"numpy\"\n)\n# now loop through the above array and only install if there's no flag file\nfor pkg in \"${pip_installs[@]}\"\ndo\necho \"INSTALL ${pkg}?\"\nif [ ! -f \"${pip_flagDir}/.${pkg}_installed\" ]; then\necho \"installing ${pkg} now\"\npip install $pkg\npkg_installed=$?\nif (( pkg_installed &lt; 1 )); then\ntouch $pip_flagDir/.${pkg}_installed\n    fi\nelse\necho \"${pkg} previously installed\"\nfi\ndone\n\n# enables debug mode\n# export DEBUG=1\n\n# Set the ipython and jupyter notebook config directories to be local\nexport IPYTHONDIR=$PWD/.ipython\nexport JUPYTER_CONFIG_DIR=$PWD/.jupyter\n\necho '=================================='\necho '        environment loaded        '\necho '=================================='\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p>MAM4xx builds and runs on the following platforms:</p> <ul> <li>Mac and Linux laptops and workstations</li> <li>NERSC Perlmutter</li> <li>Compy and Constance at PNNL</li> </ul>"},{"location":"installation/#required-software","title":"Required Software","text":"<p>To build MAM4xx, you need:</p> <ul> <li>CMake v3.17+</li> <li>GNU Make</li> <li>reliable C and C++ compilers</li> <li>optionally, a working MPI installation (like OpenMPI   or MPICH), if you want to use MAM4xx in a   multi-node parallel environment</li> <li>the HAERO aerosol package interface,   which provides necessary libraries and settings.</li> </ul> <p>You can obtain all of these freely on the Linux and Mac platforms. On Linux, just use your favorite package manager. On a Mac, you can get the Clang C/C++ compiler by installing XCode, and then use a package manager like Homebrew or MacPorts to get the rest.</p> <p>For example, to download the relevant software on your Mac using Homebrew, type</p> <pre><code>brew install cmake openmpi\n</code></pre>"},{"location":"installation/#build-and-install-haero","title":"Build and Install HAERO","text":"<p>MAM4xx uses data structures and libraries provided by Haero. To build Haero, you can either</p> <ul> <li>use the build-haero.sh script, or</li> <li>follow the directions in the Haero repository itself</li> </ul>"},{"location":"installation/#clone-the-mam4xx-repository","title":"Clone the MAM4xx Repository","text":"<p>First, go get the source code at GitHub:</p> SSHHTTPS <pre><code>git clone git@github.com:eagles-project/mam4xx.git\n</code></pre> <pre><code>git clone https://github.com/eagles-project/mam4xx.git\n</code></pre> <p>This places a <code>mam4xx</code> folder into your current path.</p>"},{"location":"installation/#configure-mam4xx","title":"Configure MAM4xx","text":"<p>MAM4xx uses CMake, and accepts a number of options that specify how it should be built. In order to simplify the build process, we've provided a simple <code>setup</code> script that generates a shell script you can run to invoke CMake with the appropriate options set.</p> <p>To configure MAM4xx:</p> <ol> <li>Create a build directory by running the <code>setup</code> script from the top-level    source directory:    <pre><code>./setup build\n</code></pre></li> <li>Change to your build directory and edit the <code>config.sh</code> file to select    configuration options. Then run <code>./config.sh</code> to configure the model.</li> </ol> <p>If you prefer, you can fish the options out of the <code>setup</code> script (or your generated <code>config.sh</code> file) and feed them directly to CMake.</p>"},{"location":"installation/#build-test-and-install-mam4xx","title":"Build, Test, and Install MAM4xx","text":"<p>After you've configured MAM4xx, you can build it:</p> <ol> <li>From the build directory, type <code>make -j</code> to build the library. (If you've    configured your build for a GPU, place a number after the <code>-j</code> flag, as in    <code>make -j 8</code>).</li> <li>To run tests for the library (and the driver, if configured), type    <code>make test</code>.</li> <li>To install the model to the location indicated by <code>PREFIX</code> in your    <code>config.sh</code> script (or <code>CMAKE_INSTALL_PREFIX</code>, if you specified it manually),    type <code>make install</code>. By default, products are installed in <code>include</code>, <code>lib</code>,    <code>bin</code>, and <code>share</code> subdirectories within your build directory.</li> </ol>"},{"location":"installation/#making-code-changes-and-rebuilding","title":"Making code changes and rebuilding","text":"<p>Notice that you must build MAM4xx in a  build tree, separate from its source trees. This is standard practice in CMake-based build systems, and it allows you to build several different configurations without leaving generated and compiled files all over your source directory. However, you might have to change the way you work in order to be productive in this kind of environment.</p> <p>When you make a code change, make sure you build from the build directory that you created in step 1 above:</p> <pre><code>cd /path/to/mam4xx/build\nmake -j\n</code></pre> <p>You can also run tests from this build directory with <code>make test</code>.</p> <p>This is very different from how some people like to work. One method of making this easier is to use an editor in a dedicated window, and have another window open with a terminal, sitting in your <code>build</code> directory. If you're using a fancy modern editor, it might have a CMake-based workflow that handles all of this for you.</p> <p>The build directory has a structure that mirrors the source directory, and you can type <code>make</code> in any one of its subdirectories to do partial builds. In practice, though, it's safest to always build from the top of the build tree.</p>"},{"location":"testing/","title":"Testing Aerosol Processes","text":""}]}